"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-currency-input-field";
exports.ids = ["vendor-chunks/react-currency-input-field"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js":
/*!*******************************************************************!*\
  !*** ./node_modules/react-currency-input-field/dist/index.esm.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanValue: () => (/* binding */ cleanValue),\n/* harmony export */   \"default\": () => (/* binding */ CurrencyInput),\n/* harmony export */   formatValue: () => (/* binding */ formatValue)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  };\n  return __assign.apply(this, arguments);\n};\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\n/**\n * Escape regex char\n *\n * See: https://stackoverflow.com/questions/17885855/use-dynamic-variable-string-as-regex-pattern-in-javascript\n */\nvar escapeRegExp = function (stringToGoIntoTheRegex) {\n    return stringToGoIntoTheRegex.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n};\n\nvar abbrMap = { k: 1000, m: 1000000, b: 1000000000 };\n/**\n * Parse a value with abbreviation e.g 1k = 1000\n */\nvar parseAbbrValue = function (value, decimalSeparator) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    var reg = new RegExp(\"(\\\\d+(\".concat(escapeRegExp(decimalSeparator), \"\\\\d*)?)([kmb])$\"), 'i');\n    var match = value.match(reg);\n    if (match) {\n        var digits = match[1], abbr = match[3];\n        var multiplier = abbrMap[abbr.toLowerCase()];\n        return Number(digits.replace(decimalSeparator, '.')) * multiplier;\n    }\n    return undefined;\n};\n\n/**\n * Remove group separator from value eg. 1,000 > 1000\n */\nvar removeSeparators = function (value, separator) {\n    if (separator === void 0) { separator = ','; }\n    var reg = new RegExp(escapeRegExp(separator), 'g');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove invalid characters\n */\nvar removeInvalidChars = function (value, validChars) {\n    var chars = escapeRegExp(validChars.join(''));\n    var reg = new RegExp(\"[^\\\\d\".concat(chars, \"]\"), 'gi');\n    return value.replace(reg, '');\n};\n\n/**\n * Remove prefix, separators and extra decimals from value\n */\nvar cleanValue = function (_a) {\n    var value = _a.value, _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c, _d = _a.allowDecimals, allowDecimals = _d === void 0 ? true : _d, _e = _a.decimalsLimit, decimalsLimit = _e === void 0 ? 2 : _e, _f = _a.allowNegativeValue, allowNegativeValue = _f === void 0 ? true : _f, _g = _a.disableAbbreviations, disableAbbreviations = _g === void 0 ? false : _g, _h = _a.prefix, prefix = _h === void 0 ? '' : _h, _j = _a.transformRawValue, transformRawValue = _j === void 0 ? function (rawValue) { return rawValue; } : _j;\n    var transformedValue = transformRawValue(value);\n    if (transformedValue === '-') {\n        return transformedValue;\n    }\n    var abbreviations = disableAbbreviations ? [] : ['k', 'm', 'b'];\n    var reg = new RegExp(\"((^|\\\\D)-\\\\d)|(-\".concat(escapeRegExp(prefix), \")\"));\n    var isNegative = reg.test(transformedValue);\n    // Is there a digit before the prefix? eg. 1$\n    var _k = RegExp(\"(\\\\d+)-?\".concat(escapeRegExp(prefix))).exec(value) || [], prefixWithValue = _k[0], preValue = _k[1];\n    var withoutPrefix = prefix\n        ? prefixWithValue\n            ? transformedValue.replace(prefixWithValue, '').concat(preValue)\n            : transformedValue.replace(prefix, '')\n        : transformedValue;\n    var withoutSeparators = removeSeparators(withoutPrefix, groupSeparator);\n    var withoutInvalidChars = removeInvalidChars(withoutSeparators, __spreadArray([\n        groupSeparator,\n        decimalSeparator\n    ], abbreviations, true));\n    var valueOnly = withoutInvalidChars;\n    if (!disableAbbreviations) {\n        // disallow letter without number\n        if (abbreviations.some(function (letter) { return letter === withoutInvalidChars.toLowerCase().replace(decimalSeparator, ''); })) {\n            return '';\n        }\n        var parsed = parseAbbrValue(withoutInvalidChars, decimalSeparator);\n        if (parsed) {\n            valueOnly = String(parsed);\n        }\n    }\n    var includeNegative = isNegative && allowNegativeValue ? '-' : '';\n    if (decimalSeparator && valueOnly.includes(decimalSeparator)) {\n        var _l = withoutInvalidChars.split(decimalSeparator), int = _l[0], decimals = _l[1];\n        var trimmedDecimals = decimalsLimit && decimals ? decimals.slice(0, decimalsLimit) : decimals;\n        var includeDecimals = allowDecimals ? \"\".concat(decimalSeparator).concat(trimmedDecimals) : '';\n        return \"\".concat(includeNegative).concat(int).concat(includeDecimals);\n    }\n    return \"\".concat(includeNegative).concat(valueOnly);\n};\n\nvar fixedDecimalValue = function (value, decimalSeparator, fixedDecimalLength) {\n    if (fixedDecimalLength !== undefined && value.length > 1) {\n        if (fixedDecimalLength === 0) {\n            return value.replace(decimalSeparator, '');\n        }\n        if (value.includes(decimalSeparator)) {\n            var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n            if (decimals.length === fixedDecimalLength) {\n                return value;\n            }\n            if (decimals.length > fixedDecimalLength) {\n                return \"\".concat(int).concat(decimalSeparator).concat(decimals.slice(0, fixedDecimalLength));\n            }\n        }\n        var reg = value.length > fixedDecimalLength\n            ? new RegExp(\"(\\\\d+)(\\\\d{\".concat(fixedDecimalLength, \"})\"))\n            : new RegExp(\"(\\\\d)(\\\\d+)\");\n        var match = value.match(reg);\n        if (match) {\n            var int = match[1], decimals = match[2];\n            return \"\".concat(int).concat(decimalSeparator).concat(decimals);\n        }\n    }\n    return value;\n};\n\nvar getSuffix = function (value, _a) {\n    var _b = _a.groupSeparator, groupSeparator = _b === void 0 ? ',' : _b, _c = _a.decimalSeparator, decimalSeparator = _c === void 0 ? '.' : _c;\n    var suffixReg = new RegExp(\"\\\\d([^\".concat(escapeRegExp(groupSeparator)).concat(escapeRegExp(decimalSeparator), \"0-9]+)\"));\n    var suffixMatch = value.match(suffixReg);\n    return suffixMatch ? suffixMatch[1] : undefined;\n};\n\n/**\n * Format value with decimal separator, group separator and prefix\n */\nvar formatValue = function (options) {\n    var _value = options.value, decimalSeparator = options.decimalSeparator, intlConfig = options.intlConfig, decimalScale = options.decimalScale, _a = options.prefix, prefix = _a === void 0 ? '' : _a, _b = options.suffix, suffix = _b === void 0 ? '' : _b;\n    if (_value === '' || _value === undefined) {\n        return '';\n    }\n    if (_value === '-') {\n        return '-';\n    }\n    var isNegative = new RegExp(\"^\\\\d?-\".concat(prefix ? \"\".concat(escapeRegExp(prefix), \"?\") : '', \"\\\\d\")).test(_value);\n    var value = decimalSeparator !== '.'\n        ? replaceDecimalSeparator(_value, decimalSeparator, isNegative)\n        : _value;\n    if (decimalSeparator && decimalSeparator !== '-' && value.startsWith(decimalSeparator)) {\n        value = '0' + value;\n    }\n    var defaultNumberFormatOptions = {\n        minimumFractionDigits: decimalScale || 0,\n        maximumFractionDigits: 20,\n    };\n    var numberFormatter = intlConfig\n        ? new Intl.NumberFormat(intlConfig.locale, intlConfig.currency\n            ? __assign(__assign({}, defaultNumberFormatOptions), { style: 'currency', currency: intlConfig.currency }) : defaultNumberFormatOptions)\n        : new Intl.NumberFormat(undefined, defaultNumberFormatOptions);\n    var parts = numberFormatter.formatToParts(Number(value));\n    var formatted = replaceParts(parts, options);\n    // Does intl formatting add a suffix?\n    var intlSuffix = getSuffix(formatted, __assign({}, options));\n    // Include decimal separator if user input ends with decimal separator\n    var includeDecimalSeparator = _value.slice(-1) === decimalSeparator ? decimalSeparator : '';\n    var _c = value.match(RegExp('\\\\d+\\\\.(\\\\d+)')) || [], decimals = _c[1];\n    // Keep original decimal padding if no decimalScale\n    if (decimalScale === undefined && decimals && decimalSeparator) {\n        if (formatted.includes(decimalSeparator)) {\n            formatted = formatted.replace(RegExp(\"(\\\\d+)(\".concat(escapeRegExp(decimalSeparator), \")(\\\\d+)\"), 'g'), \"$1$2\".concat(decimals));\n        }\n        else {\n            if (intlSuffix && !suffix) {\n                formatted = formatted.replace(intlSuffix, \"\".concat(decimalSeparator).concat(decimals).concat(intlSuffix));\n            }\n            else {\n                formatted = \"\".concat(formatted).concat(decimalSeparator).concat(decimals);\n            }\n        }\n    }\n    if (suffix && includeDecimalSeparator) {\n        return \"\".concat(formatted).concat(includeDecimalSeparator).concat(suffix);\n    }\n    if (intlSuffix && includeDecimalSeparator) {\n        return formatted.replace(intlSuffix, \"\".concat(includeDecimalSeparator).concat(intlSuffix));\n    }\n    if (intlSuffix && suffix) {\n        return formatted.replace(intlSuffix, \"\".concat(includeDecimalSeparator).concat(suffix));\n    }\n    return [formatted, includeDecimalSeparator, suffix].join('');\n};\n/**\n * Before converting to Number, decimal separator has to be .\n */\nvar replaceDecimalSeparator = function (value, decimalSeparator, isNegative) {\n    var newValue = value;\n    if (decimalSeparator && decimalSeparator !== '.') {\n        newValue = newValue.replace(RegExp(escapeRegExp(decimalSeparator), 'g'), '.');\n        if (isNegative && decimalSeparator === '-') {\n            newValue = \"-\".concat(newValue.slice(1));\n        }\n    }\n    return newValue;\n};\nvar replaceParts = function (parts, _a) {\n    var prefix = _a.prefix, groupSeparator = _a.groupSeparator, decimalSeparator = _a.decimalSeparator, decimalScale = _a.decimalScale, _b = _a.disableGroupSeparators, disableGroupSeparators = _b === void 0 ? false : _b;\n    return parts\n        .reduce(function (prev, _a, i) {\n        var type = _a.type, value = _a.value;\n        if (i === 0 && prefix) {\n            if (type === 'minusSign') {\n                return [value, prefix];\n            }\n            if (type === 'currency') {\n                return __spreadArray(__spreadArray([], prev, true), [prefix], false);\n            }\n            return [prefix, value];\n        }\n        if (type === 'currency') {\n            return prefix ? prev : __spreadArray(__spreadArray([], prev, true), [value], false);\n        }\n        if (type === 'group') {\n            return !disableGroupSeparators\n                ? __spreadArray(__spreadArray([], prev, true), [groupSeparator !== undefined ? groupSeparator : value], false) : prev;\n        }\n        if (type === 'decimal') {\n            if (decimalScale !== undefined && decimalScale === 0) {\n                return prev;\n            }\n            return __spreadArray(__spreadArray([], prev, true), [decimalSeparator !== undefined ? decimalSeparator : value], false);\n        }\n        if (type === 'fraction') {\n            return __spreadArray(__spreadArray([], prev, true), [decimalScale !== undefined ? value.slice(0, decimalScale) : value], false);\n        }\n        return __spreadArray(__spreadArray([], prev, true), [value], false);\n    }, [''])\n        .join('');\n};\n\nvar defaultConfig = {\n    currencySymbol: '',\n    groupSeparator: '',\n    decimalSeparator: '',\n    prefix: '',\n    suffix: '',\n};\n/**\n * Get locale config from input or default\n */\nvar getLocaleConfig = function (intlConfig) {\n    var _a = intlConfig || {}, locale = _a.locale, currency = _a.currency;\n    var numberFormatter = locale\n        ? new Intl.NumberFormat(locale, currency ? { currency: currency, style: 'currency' } : undefined)\n        : new Intl.NumberFormat();\n    return numberFormatter.formatToParts(1000.1).reduce(function (prev, curr, i) {\n        if (curr.type === 'currency') {\n            if (i === 0) {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, prefix: curr.value });\n            }\n            else {\n                return __assign(__assign({}, prev), { currencySymbol: curr.value, suffix: curr.value });\n            }\n        }\n        if (curr.type === 'group') {\n            return __assign(__assign({}, prev), { groupSeparator: curr.value });\n        }\n        if (curr.type === 'decimal') {\n            return __assign(__assign({}, prev), { decimalSeparator: curr.value });\n        }\n        return prev;\n    }, defaultConfig);\n};\n\nvar isNumber = function (input) { return RegExp(/\\d/, 'gi').test(input); };\n\nvar padTrimValue = function (value, decimalSeparator, decimalScale) {\n    if (decimalSeparator === void 0) { decimalSeparator = '.'; }\n    if (decimalScale === undefined || value === '' || value === undefined) {\n        return value;\n    }\n    if (!value.match(/\\d/g)) {\n        return '';\n    }\n    var _a = value.split(decimalSeparator), int = _a[0], decimals = _a[1];\n    if (decimalScale === 0) {\n        return int;\n    }\n    var newValue = decimals || '';\n    if (newValue.length < decimalScale) {\n        while (newValue.length < decimalScale) {\n            newValue += '0';\n        }\n    }\n    else {\n        newValue = newValue.slice(0, decimalScale);\n    }\n    return \"\".concat(int).concat(decimalSeparator).concat(newValue);\n};\n\n/**\n * Based on the last key stroke and the cursor position, update the value\n * and reposition the cursor to the right place\n */\nvar repositionCursor = function (_a) {\n    var selectionStart = _a.selectionStart, value = _a.value, lastKeyStroke = _a.lastKeyStroke, stateValue = _a.stateValue, groupSeparator = _a.groupSeparator;\n    var cursorPosition = selectionStart;\n    var modifiedValue = value;\n    if (stateValue && cursorPosition) {\n        var splitValue = value.split('');\n        // if cursor is to right of groupSeparator and backspace pressed, delete the character to the left of the separator and reposition the cursor\n        if (lastKeyStroke === 'Backspace' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition - 1, 1);\n            cursorPosition -= 1;\n        }\n        // if cursor is to left of groupSeparator and delete pressed, delete the character to the right of the separator and reposition the cursor\n        if (lastKeyStroke === 'Delete' && stateValue[cursorPosition] === groupSeparator) {\n            splitValue.splice(cursorPosition, 1);\n            cursorPosition += 1;\n        }\n        modifiedValue = splitValue.join('');\n        return { modifiedValue: modifiedValue, cursorPosition: cursorPosition };\n    }\n    return { modifiedValue: modifiedValue, cursorPosition: selectionStart };\n};\n\nvar CurrencyInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (_a, ref) {\n    var _b = _a.allowDecimals, allowDecimals = _b === void 0 ? true : _b, _c = _a.allowNegativeValue, allowNegativeValue = _c === void 0 ? true : _c, id = _a.id, name = _a.name, className = _a.className, customInput = _a.customInput, decimalsLimit = _a.decimalsLimit, defaultValue = _a.defaultValue, _d = _a.disabled, disabled = _d === void 0 ? false : _d, userMaxLength = _a.maxLength, userValue = _a.value, onValueChange = _a.onValueChange, fixedDecimalLength = _a.fixedDecimalLength, placeholder = _a.placeholder, decimalScale = _a.decimalScale, prefix = _a.prefix, suffix = _a.suffix, intlConfig = _a.intlConfig, step = _a.step, min = _a.min, max = _a.max, _e = _a.disableGroupSeparators, disableGroupSeparators = _e === void 0 ? false : _e, _f = _a.disableAbbreviations, disableAbbreviations = _f === void 0 ? false : _f, _decimalSeparator = _a.decimalSeparator, _groupSeparator = _a.groupSeparator, onChange = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, onKeyDown = _a.onKeyDown, onKeyUp = _a.onKeyUp, transformRawValue = _a.transformRawValue, _g = _a.formatValueOnBlur, formatValueOnBlur = _g === void 0 ? true : _g, props = __rest(_a, [\"allowDecimals\", \"allowNegativeValue\", \"id\", \"name\", \"className\", \"customInput\", \"decimalsLimit\", \"defaultValue\", \"disabled\", \"maxLength\", \"value\", \"onValueChange\", \"fixedDecimalLength\", \"placeholder\", \"decimalScale\", \"prefix\", \"suffix\", \"intlConfig\", \"step\", \"min\", \"max\", \"disableGroupSeparators\", \"disableAbbreviations\", \"decimalSeparator\", \"groupSeparator\", \"onChange\", \"onFocus\", \"onBlur\", \"onKeyDown\", \"onKeyUp\", \"transformRawValue\", \"formatValueOnBlur\"]);\n    if (_decimalSeparator && isNumber(_decimalSeparator)) {\n        throw new Error('decimalSeparator cannot be a number');\n    }\n    if (_groupSeparator && isNumber(_groupSeparator)) {\n        throw new Error('groupSeparator cannot be a number');\n    }\n    var localeConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () { return getLocaleConfig(intlConfig); }, [intlConfig]);\n    var decimalSeparator = _decimalSeparator || localeConfig.decimalSeparator || '';\n    var groupSeparator = _groupSeparator || localeConfig.groupSeparator || '';\n    if (decimalSeparator &&\n        groupSeparator &&\n        decimalSeparator === groupSeparator &&\n        disableGroupSeparators === false) {\n        throw new Error('decimalSeparator cannot be the same as groupSeparator');\n    }\n    var formatValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        disableGroupSeparators: disableGroupSeparators,\n        intlConfig: intlConfig,\n        prefix: prefix || localeConfig.prefix,\n        suffix: suffix,\n    };\n    var cleanValueOptions = {\n        decimalSeparator: decimalSeparator,\n        groupSeparator: groupSeparator,\n        allowDecimals: allowDecimals,\n        decimalsLimit: decimalsLimit || fixedDecimalLength || 2,\n        allowNegativeValue: allowNegativeValue,\n        disableAbbreviations: disableAbbreviations,\n        prefix: prefix || localeConfig.prefix,\n        transformRawValue: transformRawValue,\n    };\n    var _h = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(function () {\n        return defaultValue != null\n            ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(defaultValue) }))\n            : userValue != null\n                ? formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: decimalScale, value: String(userValue) }))\n                : '';\n    }), stateValue = _h[0], setStateValue = _h[1];\n    var _j = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false), dirty = _j[0], setDirty = _j[1];\n    var _k = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), cursor = _k[0], setCursor = _k[1];\n    var _l = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0), changeCount = _l[0], setChangeCount = _l[1];\n    var _m = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null), lastKeyStroke = _m[0], setLastKeyStroke = _m[1];\n    var inputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () { return inputRef.current; });\n    /**\n     * Process change in value\n     */\n    var processChange = function (value, selectionStart) {\n        setDirty(true);\n        var _a = repositionCursor({\n            selectionStart: selectionStart,\n            value: value,\n            lastKeyStroke: lastKeyStroke,\n            stateValue: stateValue,\n            groupSeparator: groupSeparator,\n        }), modifiedValue = _a.modifiedValue, cursorPosition = _a.cursorPosition;\n        var stringValue = cleanValue(__assign({ value: modifiedValue }, cleanValueOptions));\n        if (userMaxLength && stringValue.replace(/-/g, '').length > userMaxLength) {\n            return;\n        }\n        if (stringValue === '' || stringValue === '-' || stringValue === decimalSeparator) {\n            onValueChange && onValueChange(undefined, name, { float: null, formatted: '', value: '' });\n            setStateValue(stringValue);\n            // Always sets cursor after '-' or decimalSeparator input\n            setCursor(1);\n            return;\n        }\n        var stringValueWithoutSeparator = decimalSeparator\n            ? stringValue.replace(decimalSeparator, '.')\n            : stringValue;\n        var numberValue = parseFloat(stringValueWithoutSeparator);\n        var formattedValue = formatValue(__assign({ value: stringValue }, formatValueOptions));\n        if (cursorPosition != null) {\n            // Prevent cursor jumping\n            var newCursor = cursorPosition + (formattedValue.length - value.length);\n            newCursor = newCursor <= 0 ? (prefix ? prefix.length : 0) : newCursor;\n            setCursor(newCursor);\n            setChangeCount(changeCount + 1);\n        }\n        setStateValue(formattedValue);\n        if (onValueChange) {\n            var values = {\n                float: numberValue,\n                formatted: formattedValue,\n                value: stringValue,\n            };\n            onValueChange(stringValue, name, values);\n        }\n    };\n    /**\n     * Handle change event\n     */\n    var handleOnChange = function (event) {\n        var _a = event.target, value = _a.value, selectionStart = _a.selectionStart;\n        processChange(value, selectionStart);\n        onChange && onChange(event);\n    };\n    /**\n     * Handle focus event\n     */\n    var handleOnFocus = function (event) {\n        onFocus && onFocus(event);\n        return stateValue ? stateValue.length : 0;\n    };\n    /**\n     * Handle blur event\n     *\n     * Format value by padding/trimming decimals if required by\n     */\n    var handleOnBlur = function (event) {\n        var value = event.target.value;\n        var valueOnly = cleanValue(__assign({ value: value }, cleanValueOptions));\n        if (valueOnly === '-' || valueOnly === decimalSeparator || !valueOnly) {\n            setStateValue('');\n            onBlur && onBlur(event);\n            return;\n        }\n        var fixedDecimals = fixedDecimalValue(valueOnly, decimalSeparator, fixedDecimalLength);\n        var newValue = padTrimValue(fixedDecimals, decimalSeparator, decimalScale !== undefined ? decimalScale : fixedDecimalLength);\n        var numberValue = parseFloat(newValue.replace(decimalSeparator, '.'));\n        var formattedValue = formatValue(__assign(__assign({}, formatValueOptions), { value: newValue }));\n        if (onValueChange && formatValueOnBlur) {\n            onValueChange(newValue, name, {\n                float: numberValue,\n                formatted: formattedValue,\n                value: newValue,\n            });\n        }\n        setStateValue(formattedValue);\n        onBlur && onBlur(event);\n    };\n    /**\n     * Handle key down event\n     *\n     * Increase or decrease value by step\n     */\n    var handleOnKeyDown = function (event) {\n        var key = event.key;\n        setLastKeyStroke(key);\n        if (step && (key === 'ArrowUp' || key === 'ArrowDown')) {\n            event.preventDefault();\n            setCursor(stateValue.length);\n            var currentValue = parseFloat(userValue != null\n                ? String(userValue).replace(decimalSeparator, '.')\n                : cleanValue(__assign({ value: stateValue }, cleanValueOptions))) || 0;\n            var newValue = key === 'ArrowUp' ? currentValue + step : currentValue - step;\n            if (min !== undefined && newValue < Number(min)) {\n                return;\n            }\n            if (max !== undefined && newValue > Number(max)) {\n                return;\n            }\n            var fixedLength = String(step).includes('.')\n                ? Number(String(step).split('.')[1].length)\n                : undefined;\n            processChange(String(fixedLength ? newValue.toFixed(fixedLength) : newValue).replace('.', decimalSeparator));\n        }\n        onKeyDown && onKeyDown(event);\n    };\n    /**\n     * Handle key up event\n     *\n     * Move cursor if there is a suffix to prevent user typing past suffix\n     */\n    var handleOnKeyUp = function (event) {\n        var key = event.key, selectionStart = event.currentTarget.selectionStart;\n        if (key !== 'ArrowUp' && key !== 'ArrowDown' && stateValue !== '-') {\n            var suffix_1 = getSuffix(stateValue, { groupSeparator: groupSeparator, decimalSeparator: decimalSeparator });\n            if (suffix_1 && selectionStart && selectionStart > stateValue.length - suffix_1.length) {\n                /* istanbul ignore else */\n                if (inputRef.current) {\n                    var newCursor = stateValue.length - suffix_1.length;\n                    inputRef.current.setSelectionRange(newCursor, newCursor);\n                }\n            }\n        }\n        onKeyUp && onKeyUp(event);\n    };\n    // Update state if userValue changes to undefined\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        if (userValue == null && defaultValue == null) {\n            setStateValue('');\n        }\n    }, [defaultValue, userValue]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n        // prevent cursor jumping if editing value\n        if (dirty &&\n            stateValue !== '-' &&\n            inputRef.current &&\n            document.activeElement === inputRef.current) {\n            inputRef.current.setSelectionRange(cursor, cursor);\n        }\n    }, [stateValue, cursor, inputRef, dirty, changeCount]);\n    /**\n     * If user has only entered \"-\" or decimal separator,\n     * keep the char to allow them to enter next value\n     */\n    var getRenderValue = function () {\n        if (userValue != null &&\n            stateValue !== '-' &&\n            (!decimalSeparator || stateValue !== decimalSeparator)) {\n            return formatValue(__assign(__assign({}, formatValueOptions), { decimalScale: dirty ? undefined : decimalScale, value: String(userValue) }));\n        }\n        return stateValue;\n    };\n    var inputProps = __assign({ type: 'text', inputMode: 'decimal', id: id, name: name, className: className, onChange: handleOnChange, onBlur: handleOnBlur, onFocus: handleOnFocus, onKeyDown: handleOnKeyDown, onKeyUp: handleOnKeyUp, placeholder: placeholder, disabled: disabled, value: getRenderValue(), ref: inputRef }, props);\n    if (customInput) {\n        var CustomInput = customInput;\n        return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(CustomInput, __assign({}, inputProps));\n    }\n    return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"input\", __assign({}, inputProps));\n});\nCurrencyInput.displayName = 'CurrencyInput';\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtY3VycmVuY3ktaW5wdXQtZmllbGQvZGlzdC9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUc7O0FBRXJHO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsT0FBTztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELGNBQWM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJFQUEyRSxPQUFPO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseWtCQUF5a0IsbUJBQW1CO0FBQzVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxvRkFBb0Y7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQSxlQUFlLDBEQUFtQix5QkFBeUI7QUFDM0Q7QUFDQSxXQUFXLDBEQUFtQixxQkFBcUI7QUFDbkQsQ0FBQztBQUNEOztBQUU2RDtBQUM3RCIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1jdXJyZW5jeS1pbnB1dC1maWVsZC9kaXN0L2luZGV4LmVzbS5qcz9hMjJlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VNZW1vLCB1c2VTdGF0ZSwgdXNlUmVmLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxuXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cblxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfTtcbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59O1xuXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcbiAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn1cblxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XG4gIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xufTtcblxuLyoqXG4gKiBFc2NhcGUgcmVnZXggY2hhclxuICpcbiAqIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTc4ODU4NTUvdXNlLWR5bmFtaWMtdmFyaWFibGUtc3RyaW5nLWFzLXJlZ2V4LXBhdHRlcm4taW4tamF2YXNjcmlwdFxuICovXG52YXIgZXNjYXBlUmVnRXhwID0gZnVuY3Rpb24gKHN0cmluZ1RvR29JbnRvVGhlUmVnZXgpIHtcbiAgICByZXR1cm4gc3RyaW5nVG9Hb0ludG9UaGVSZWdleC5yZXBsYWNlKC9bLS9cXFxcXiQqKz8uKCl8W1xcXXt9XS9nLCAnXFxcXCQmJyk7XG59O1xuXG52YXIgYWJick1hcCA9IHsgazogMTAwMCwgbTogMTAwMDAwMCwgYjogMTAwMDAwMDAwMCB9O1xuLyoqXG4gKiBQYXJzZSBhIHZhbHVlIHdpdGggYWJicmV2aWF0aW9uIGUuZyAxayA9IDEwMDBcbiAqL1xudmFyIHBhcnNlQWJiclZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBkZWNpbWFsU2VwYXJhdG9yID0gJy4nOyB9XG4gICAgdmFyIHJlZyA9IG5ldyBSZWdFeHAoXCIoXFxcXGQrKFwiLmNvbmNhdChlc2NhcGVSZWdFeHAoZGVjaW1hbFNlcGFyYXRvciksIFwiXFxcXGQqKT8pKFtrbWJdKSRcIiksICdpJyk7XG4gICAgdmFyIG1hdGNoID0gdmFsdWUubWF0Y2gocmVnKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdmFyIGRpZ2l0cyA9IG1hdGNoWzFdLCBhYmJyID0gbWF0Y2hbM107XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gYWJick1hcFthYmJyLnRvTG93ZXJDYXNlKCldO1xuICAgICAgICByZXR1cm4gTnVtYmVyKGRpZ2l0cy5yZXBsYWNlKGRlY2ltYWxTZXBhcmF0b3IsICcuJykpICogbXVsdGlwbGllcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGdyb3VwIHNlcGFyYXRvciBmcm9tIHZhbHVlIGVnLiAxLDAwMCA+IDEwMDBcbiAqL1xudmFyIHJlbW92ZVNlcGFyYXRvcnMgPSBmdW5jdGlvbiAodmFsdWUsIHNlcGFyYXRvcikge1xuICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCkgeyBzZXBhcmF0b3IgPSAnLCc7IH1cbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAoc2VwYXJhdG9yKSwgJ2cnKTtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWcsICcnKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGludmFsaWQgY2hhcmFjdGVyc1xuICovXG52YXIgcmVtb3ZlSW52YWxpZENoYXJzID0gZnVuY3Rpb24gKHZhbHVlLCB2YWxpZENoYXJzKSB7XG4gICAgdmFyIGNoYXJzID0gZXNjYXBlUmVnRXhwKHZhbGlkQ2hhcnMuam9pbignJykpO1xuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiW15cXFxcZFwiLmNvbmNhdChjaGFycywgXCJdXCIpLCAnZ2knKTtcbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZShyZWcsICcnKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHByZWZpeCwgc2VwYXJhdG9ycyBhbmQgZXh0cmEgZGVjaW1hbHMgZnJvbSB2YWx1ZVxuICovXG52YXIgY2xlYW5WYWx1ZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciB2YWx1ZSA9IF9hLnZhbHVlLCBfYiA9IF9hLmdyb3VwU2VwYXJhdG9yLCBncm91cFNlcGFyYXRvciA9IF9iID09PSB2b2lkIDAgPyAnLCcgOiBfYiwgX2MgPSBfYS5kZWNpbWFsU2VwYXJhdG9yLCBkZWNpbWFsU2VwYXJhdG9yID0gX2MgPT09IHZvaWQgMCA/ICcuJyA6IF9jLCBfZCA9IF9hLmFsbG93RGVjaW1hbHMsIGFsbG93RGVjaW1hbHMgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kLCBfZSA9IF9hLmRlY2ltYWxzTGltaXQsIGRlY2ltYWxzTGltaXQgPSBfZSA9PT0gdm9pZCAwID8gMiA6IF9lLCBfZiA9IF9hLmFsbG93TmVnYXRpdmVWYWx1ZSwgYWxsb3dOZWdhdGl2ZVZhbHVlID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZiwgX2cgPSBfYS5kaXNhYmxlQWJicmV2aWF0aW9ucywgZGlzYWJsZUFiYnJldmlhdGlvbnMgPSBfZyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZywgX2ggPSBfYS5wcmVmaXgsIHByZWZpeCA9IF9oID09PSB2b2lkIDAgPyAnJyA6IF9oLCBfaiA9IF9hLnRyYW5zZm9ybVJhd1ZhbHVlLCB0cmFuc2Zvcm1SYXdWYWx1ZSA9IF9qID09PSB2b2lkIDAgPyBmdW5jdGlvbiAocmF3VmFsdWUpIHsgcmV0dXJuIHJhd1ZhbHVlOyB9IDogX2o7XG4gICAgdmFyIHRyYW5zZm9ybWVkVmFsdWUgPSB0cmFuc2Zvcm1SYXdWYWx1ZSh2YWx1ZSk7XG4gICAgaWYgKHRyYW5zZm9ybWVkVmFsdWUgPT09ICctJykge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWRWYWx1ZTtcbiAgICB9XG4gICAgdmFyIGFiYnJldmlhdGlvbnMgPSBkaXNhYmxlQWJicmV2aWF0aW9ucyA/IFtdIDogWydrJywgJ20nLCAnYiddO1xuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKFwiKChefFxcXFxEKS1cXFxcZCl8KC1cIi5jb25jYXQoZXNjYXBlUmVnRXhwKHByZWZpeCksIFwiKVwiKSk7XG4gICAgdmFyIGlzTmVnYXRpdmUgPSByZWcudGVzdCh0cmFuc2Zvcm1lZFZhbHVlKTtcbiAgICAvLyBJcyB0aGVyZSBhIGRpZ2l0IGJlZm9yZSB0aGUgcHJlZml4PyBlZy4gMSRcbiAgICB2YXIgX2sgPSBSZWdFeHAoXCIoXFxcXGQrKS0/XCIuY29uY2F0KGVzY2FwZVJlZ0V4cChwcmVmaXgpKSkuZXhlYyh2YWx1ZSkgfHwgW10sIHByZWZpeFdpdGhWYWx1ZSA9IF9rWzBdLCBwcmVWYWx1ZSA9IF9rWzFdO1xuICAgIHZhciB3aXRob3V0UHJlZml4ID0gcHJlZml4XG4gICAgICAgID8gcHJlZml4V2l0aFZhbHVlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybWVkVmFsdWUucmVwbGFjZShwcmVmaXhXaXRoVmFsdWUsICcnKS5jb25jYXQocHJlVmFsdWUpXG4gICAgICAgICAgICA6IHRyYW5zZm9ybWVkVmFsdWUucmVwbGFjZShwcmVmaXgsICcnKVxuICAgICAgICA6IHRyYW5zZm9ybWVkVmFsdWU7XG4gICAgdmFyIHdpdGhvdXRTZXBhcmF0b3JzID0gcmVtb3ZlU2VwYXJhdG9ycyh3aXRob3V0UHJlZml4LCBncm91cFNlcGFyYXRvcik7XG4gICAgdmFyIHdpdGhvdXRJbnZhbGlkQ2hhcnMgPSByZW1vdmVJbnZhbGlkQ2hhcnMod2l0aG91dFNlcGFyYXRvcnMsIF9fc3ByZWFkQXJyYXkoW1xuICAgICAgICBncm91cFNlcGFyYXRvcixcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvclxuICAgIF0sIGFiYnJldmlhdGlvbnMsIHRydWUpKTtcbiAgICB2YXIgdmFsdWVPbmx5ID0gd2l0aG91dEludmFsaWRDaGFycztcbiAgICBpZiAoIWRpc2FibGVBYmJyZXZpYXRpb25zKSB7XG4gICAgICAgIC8vIGRpc2FsbG93IGxldHRlciB3aXRob3V0IG51bWJlclxuICAgICAgICBpZiAoYWJicmV2aWF0aW9ucy5zb21lKGZ1bmN0aW9uIChsZXR0ZXIpIHsgcmV0dXJuIGxldHRlciA9PT0gd2l0aG91dEludmFsaWRDaGFycy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJycpOyB9KSkge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBwYXJzZWQgPSBwYXJzZUFiYnJWYWx1ZSh3aXRob3V0SW52YWxpZENoYXJzLCBkZWNpbWFsU2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgdmFsdWVPbmx5ID0gU3RyaW5nKHBhcnNlZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGluY2x1ZGVOZWdhdGl2ZSA9IGlzTmVnYXRpdmUgJiYgYWxsb3dOZWdhdGl2ZVZhbHVlID8gJy0nIDogJyc7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgJiYgdmFsdWVPbmx5LmluY2x1ZGVzKGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgIHZhciBfbCA9IHdpdGhvdXRJbnZhbGlkQ2hhcnMuc3BsaXQoZGVjaW1hbFNlcGFyYXRvciksIGludCA9IF9sWzBdLCBkZWNpbWFscyA9IF9sWzFdO1xuICAgICAgICB2YXIgdHJpbW1lZERlY2ltYWxzID0gZGVjaW1hbHNMaW1pdCAmJiBkZWNpbWFscyA/IGRlY2ltYWxzLnNsaWNlKDAsIGRlY2ltYWxzTGltaXQpIDogZGVjaW1hbHM7XG4gICAgICAgIHZhciBpbmNsdWRlRGVjaW1hbHMgPSBhbGxvd0RlY2ltYWxzID8gXCJcIi5jb25jYXQoZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KHRyaW1tZWREZWNpbWFscykgOiAnJztcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGluY2x1ZGVOZWdhdGl2ZSkuY29uY2F0KGludCkuY29uY2F0KGluY2x1ZGVEZWNpbWFscyk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdChpbmNsdWRlTmVnYXRpdmUpLmNvbmNhdCh2YWx1ZU9ubHkpO1xufTtcblxudmFyIGZpeGVkRGVjaW1hbFZhbHVlID0gZnVuY3Rpb24gKHZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yLCBmaXhlZERlY2ltYWxMZW5ndGgpIHtcbiAgICBpZiAoZml4ZWREZWNpbWFsTGVuZ3RoICE9PSB1bmRlZmluZWQgJiYgdmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICBpZiAoZml4ZWREZWNpbWFsTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSB2YWx1ZS5zcGxpdChkZWNpbWFsU2VwYXJhdG9yKSwgaW50ID0gX2FbMF0sIGRlY2ltYWxzID0gX2FbMV07XG4gICAgICAgICAgICBpZiAoZGVjaW1hbHMubGVuZ3RoID09PSBmaXhlZERlY2ltYWxMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVjaW1hbHMubGVuZ3RoID4gZml4ZWREZWNpbWFsTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGludCkuY29uY2F0KGRlY2ltYWxTZXBhcmF0b3IpLmNvbmNhdChkZWNpbWFscy5zbGljZSgwLCBmaXhlZERlY2ltYWxMZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVnID0gdmFsdWUubGVuZ3RoID4gZml4ZWREZWNpbWFsTGVuZ3RoXG4gICAgICAgICAgICA/IG5ldyBSZWdFeHAoXCIoXFxcXGQrKShcXFxcZHtcIi5jb25jYXQoZml4ZWREZWNpbWFsTGVuZ3RoLCBcIn0pXCIpKVxuICAgICAgICAgICAgOiBuZXcgUmVnRXhwKFwiKFxcXFxkKShcXFxcZCspXCIpO1xuICAgICAgICB2YXIgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWcpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBpbnQgPSBtYXRjaFsxXSwgZGVjaW1hbHMgPSBtYXRjaFsyXTtcbiAgICAgICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChpbnQpLmNvbmNhdChkZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQoZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn07XG5cbnZhciBnZXRTdWZmaXggPSBmdW5jdGlvbiAodmFsdWUsIF9hKSB7XG4gICAgdmFyIF9iID0gX2EuZ3JvdXBTZXBhcmF0b3IsIGdyb3VwU2VwYXJhdG9yID0gX2IgPT09IHZvaWQgMCA/ICcsJyA6IF9iLCBfYyA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTZXBhcmF0b3IgPSBfYyA9PT0gdm9pZCAwID8gJy4nIDogX2M7XG4gICAgdmFyIHN1ZmZpeFJlZyA9IG5ldyBSZWdFeHAoXCJcXFxcZChbXlwiLmNvbmNhdChlc2NhcGVSZWdFeHAoZ3JvdXBTZXBhcmF0b3IpKS5jb25jYXQoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpLCBcIjAtOV0rKVwiKSk7XG4gICAgdmFyIHN1ZmZpeE1hdGNoID0gdmFsdWUubWF0Y2goc3VmZml4UmVnKTtcbiAgICByZXR1cm4gc3VmZml4TWF0Y2ggPyBzdWZmaXhNYXRjaFsxXSA6IHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRm9ybWF0IHZhbHVlIHdpdGggZGVjaW1hbCBzZXBhcmF0b3IsIGdyb3VwIHNlcGFyYXRvciBhbmQgcHJlZml4XG4gKi9cbnZhciBmb3JtYXRWYWx1ZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIF92YWx1ZSA9IG9wdGlvbnMudmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IgPSBvcHRpb25zLmRlY2ltYWxTZXBhcmF0b3IsIGludGxDb25maWcgPSBvcHRpb25zLmludGxDb25maWcsIGRlY2ltYWxTY2FsZSA9IG9wdGlvbnMuZGVjaW1hbFNjYWxlLCBfYSA9IG9wdGlvbnMucHJlZml4LCBwcmVmaXggPSBfYSA9PT0gdm9pZCAwID8gJycgOiBfYSwgX2IgPSBvcHRpb25zLnN1ZmZpeCwgc3VmZml4ID0gX2IgPT09IHZvaWQgMCA/ICcnIDogX2I7XG4gICAgaWYgKF92YWx1ZSA9PT0gJycgfHwgX3ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgICBpZiAoX3ZhbHVlID09PSAnLScpIHtcbiAgICAgICAgcmV0dXJuICctJztcbiAgICB9XG4gICAgdmFyIGlzTmVnYXRpdmUgPSBuZXcgUmVnRXhwKFwiXlxcXFxkPy1cIi5jb25jYXQocHJlZml4ID8gXCJcIi5jb25jYXQoZXNjYXBlUmVnRXhwKHByZWZpeCksIFwiP1wiKSA6ICcnLCBcIlxcXFxkXCIpKS50ZXN0KF92YWx1ZSk7XG4gICAgdmFyIHZhbHVlID0gZGVjaW1hbFNlcGFyYXRvciAhPT0gJy4nXG4gICAgICAgID8gcmVwbGFjZURlY2ltYWxTZXBhcmF0b3IoX3ZhbHVlLCBkZWNpbWFsU2VwYXJhdG9yLCBpc05lZ2F0aXZlKVxuICAgICAgICA6IF92YWx1ZTtcbiAgICBpZiAoZGVjaW1hbFNlcGFyYXRvciAmJiBkZWNpbWFsU2VwYXJhdG9yICE9PSAnLScgJiYgdmFsdWUuc3RhcnRzV2l0aChkZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICB2YWx1ZSA9ICcwJyArIHZhbHVlO1xuICAgIH1cbiAgICB2YXIgZGVmYXVsdE51bWJlckZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICAgIG1pbmltdW1GcmFjdGlvbkRpZ2l0czogZGVjaW1hbFNjYWxlIHx8IDAsXG4gICAgICAgIG1heGltdW1GcmFjdGlvbkRpZ2l0czogMjAsXG4gICAgfTtcbiAgICB2YXIgbnVtYmVyRm9ybWF0dGVyID0gaW50bENvbmZpZ1xuICAgICAgICA/IG5ldyBJbnRsLk51bWJlckZvcm1hdChpbnRsQ29uZmlnLmxvY2FsZSwgaW50bENvbmZpZy5jdXJyZW5jeVxuICAgICAgICAgICAgPyBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZGVmYXVsdE51bWJlckZvcm1hdE9wdGlvbnMpLCB7IHN0eWxlOiAnY3VycmVuY3knLCBjdXJyZW5jeTogaW50bENvbmZpZy5jdXJyZW5jeSB9KSA6IGRlZmF1bHROdW1iZXJGb3JtYXRPcHRpb25zKVxuICAgICAgICA6IG5ldyBJbnRsLk51bWJlckZvcm1hdCh1bmRlZmluZWQsIGRlZmF1bHROdW1iZXJGb3JtYXRPcHRpb25zKTtcbiAgICB2YXIgcGFydHMgPSBudW1iZXJGb3JtYXR0ZXIuZm9ybWF0VG9QYXJ0cyhOdW1iZXIodmFsdWUpKTtcbiAgICB2YXIgZm9ybWF0dGVkID0gcmVwbGFjZVBhcnRzKHBhcnRzLCBvcHRpb25zKTtcbiAgICAvLyBEb2VzIGludGwgZm9ybWF0dGluZyBhZGQgYSBzdWZmaXg/XG4gICAgdmFyIGludGxTdWZmaXggPSBnZXRTdWZmaXgoZm9ybWF0dGVkLCBfX2Fzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgIC8vIEluY2x1ZGUgZGVjaW1hbCBzZXBhcmF0b3IgaWYgdXNlciBpbnB1dCBlbmRzIHdpdGggZGVjaW1hbCBzZXBhcmF0b3JcbiAgICB2YXIgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IgPSBfdmFsdWUuc2xpY2UoLTEpID09PSBkZWNpbWFsU2VwYXJhdG9yID8gZGVjaW1hbFNlcGFyYXRvciA6ICcnO1xuICAgIHZhciBfYyA9IHZhbHVlLm1hdGNoKFJlZ0V4cCgnXFxcXGQrXFxcXC4oXFxcXGQrKScpKSB8fCBbXSwgZGVjaW1hbHMgPSBfY1sxXTtcbiAgICAvLyBLZWVwIG9yaWdpbmFsIGRlY2ltYWwgcGFkZGluZyBpZiBubyBkZWNpbWFsU2NhbGVcbiAgICBpZiAoZGVjaW1hbFNjYWxlID09PSB1bmRlZmluZWQgJiYgZGVjaW1hbHMgJiYgZGVjaW1hbFNlcGFyYXRvcikge1xuICAgICAgICBpZiAoZm9ybWF0dGVkLmluY2x1ZGVzKGRlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWQgPSBmb3JtYXR0ZWQucmVwbGFjZShSZWdFeHAoXCIoXFxcXGQrKShcIi5jb25jYXQoZXNjYXBlUmVnRXhwKGRlY2ltYWxTZXBhcmF0b3IpLCBcIikoXFxcXGQrKVwiKSwgJ2cnKSwgXCIkMSQyXCIuY29uY2F0KGRlY2ltYWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaW50bFN1ZmZpeCAmJiAhc3VmZml4KSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gZm9ybWF0dGVkLnJlcGxhY2UoaW50bFN1ZmZpeCwgXCJcIi5jb25jYXQoZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KGRlY2ltYWxzKS5jb25jYXQoaW50bFN1ZmZpeCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkID0gXCJcIi5jb25jYXQoZm9ybWF0dGVkKS5jb25jYXQoZGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KGRlY2ltYWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3VmZml4ICYmIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBcIlwiLmNvbmNhdChmb3JtYXR0ZWQpLmNvbmNhdChpbmNsdWRlRGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KHN1ZmZpeCk7XG4gICAgfVxuICAgIGlmIChpbnRsU3VmZml4ICYmIGluY2x1ZGVEZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQucmVwbGFjZShpbnRsU3VmZml4LCBcIlwiLmNvbmNhdChpbmNsdWRlRGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KGludGxTdWZmaXgpKTtcbiAgICB9XG4gICAgaWYgKGludGxTdWZmaXggJiYgc3VmZml4KSB7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQucmVwbGFjZShpbnRsU3VmZml4LCBcIlwiLmNvbmNhdChpbmNsdWRlRGVjaW1hbFNlcGFyYXRvcikuY29uY2F0KHN1ZmZpeCkpO1xuICAgIH1cbiAgICByZXR1cm4gW2Zvcm1hdHRlZCwgaW5jbHVkZURlY2ltYWxTZXBhcmF0b3IsIHN1ZmZpeF0uam9pbignJyk7XG59O1xuLyoqXG4gKiBCZWZvcmUgY29udmVydGluZyB0byBOdW1iZXIsIGRlY2ltYWwgc2VwYXJhdG9yIGhhcyB0byBiZSAuXG4gKi9cbnZhciByZXBsYWNlRGVjaW1hbFNlcGFyYXRvciA9IGZ1bmN0aW9uICh2YWx1ZSwgZGVjaW1hbFNlcGFyYXRvciwgaXNOZWdhdGl2ZSkge1xuICAgIHZhciBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yICYmIGRlY2ltYWxTZXBhcmF0b3IgIT09ICcuJykge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnJlcGxhY2UoUmVnRXhwKGVzY2FwZVJlZ0V4cChkZWNpbWFsU2VwYXJhdG9yKSwgJ2cnKSwgJy4nKTtcbiAgICAgICAgaWYgKGlzTmVnYXRpdmUgJiYgZGVjaW1hbFNlcGFyYXRvciA9PT0gJy0nKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFwiLVwiLmNvbmNhdChuZXdWYWx1ZS5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlO1xufTtcbnZhciByZXBsYWNlUGFydHMgPSBmdW5jdGlvbiAocGFydHMsIF9hKSB7XG4gICAgdmFyIHByZWZpeCA9IF9hLnByZWZpeCwgZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvciA9IF9hLmRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTY2FsZSA9IF9hLmRlY2ltYWxTY2FsZSwgX2IgPSBfYS5kaXNhYmxlR3JvdXBTZXBhcmF0b3JzLCBkaXNhYmxlR3JvdXBTZXBhcmF0b3JzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgcmV0dXJuIHBhcnRzXG4gICAgICAgIC5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIF9hLCBpKSB7XG4gICAgICAgIHZhciB0eXBlID0gX2EudHlwZSwgdmFsdWUgPSBfYS52YWx1ZTtcbiAgICAgICAgaWYgKGkgPT09IDAgJiYgcHJlZml4KSB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ21pbnVzU2lnbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3ZhbHVlLCBwcmVmaXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW3ByZWZpeF0sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBbcHJlZml4LCB2YWx1ZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggPyBwcmV2IDogX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KFtdLCBwcmV2LCB0cnVlKSwgW3ZhbHVlXSwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICAgICAgICByZXR1cm4gIWRpc2FibGVHcm91cFNlcGFyYXRvcnNcbiAgICAgICAgICAgICAgICA/IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiwgdHJ1ZSksIFtncm91cFNlcGFyYXRvciAhPT0gdW5kZWZpbmVkID8gZ3JvdXBTZXBhcmF0b3IgOiB2YWx1ZV0sIGZhbHNlKSA6IHByZXY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdkZWNpbWFsJykge1xuICAgICAgICAgICAgaWYgKGRlY2ltYWxTY2FsZSAhPT0gdW5kZWZpbmVkICYmIGRlY2ltYWxTY2FsZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcmV2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiwgdHJ1ZSksIFtkZWNpbWFsU2VwYXJhdG9yICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsU2VwYXJhdG9yIDogdmFsdWVdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09ICdmcmFjdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIHByZXYsIHRydWUpLCBbZGVjaW1hbFNjYWxlICE9PSB1bmRlZmluZWQgPyB2YWx1ZS5zbGljZSgwLCBkZWNpbWFsU2NhbGUpIDogdmFsdWVdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgcHJldiwgdHJ1ZSksIFt2YWx1ZV0sIGZhbHNlKTtcbiAgICB9LCBbJyddKVxuICAgICAgICAuam9pbignJyk7XG59O1xuXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgICBjdXJyZW5jeVN5bWJvbDogJycsXG4gICAgZ3JvdXBTZXBhcmF0b3I6ICcnLFxuICAgIGRlY2ltYWxTZXBhcmF0b3I6ICcnLFxuICAgIHByZWZpeDogJycsXG4gICAgc3VmZml4OiAnJyxcbn07XG4vKipcbiAqIEdldCBsb2NhbGUgY29uZmlnIGZyb20gaW5wdXQgb3IgZGVmYXVsdFxuICovXG52YXIgZ2V0TG9jYWxlQ29uZmlnID0gZnVuY3Rpb24gKGludGxDb25maWcpIHtcbiAgICB2YXIgX2EgPSBpbnRsQ29uZmlnIHx8IHt9LCBsb2NhbGUgPSBfYS5sb2NhbGUsIGN1cnJlbmN5ID0gX2EuY3VycmVuY3k7XG4gICAgdmFyIG51bWJlckZvcm1hdHRlciA9IGxvY2FsZVxuICAgICAgICA/IG5ldyBJbnRsLk51bWJlckZvcm1hdChsb2NhbGUsIGN1cnJlbmN5ID8geyBjdXJyZW5jeTogY3VycmVuY3ksIHN0eWxlOiAnY3VycmVuY3knIH0gOiB1bmRlZmluZWQpXG4gICAgICAgIDogbmV3IEludGwuTnVtYmVyRm9ybWF0KCk7XG4gICAgcmV0dXJuIG51bWJlckZvcm1hdHRlci5mb3JtYXRUb1BhcnRzKDEwMDAuMSkucmVkdWNlKGZ1bmN0aW9uIChwcmV2LCBjdXJyLCBpKSB7XG4gICAgICAgIGlmIChjdXJyLnR5cGUgPT09ICdjdXJyZW5jeScpIHtcbiAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBjdXJyZW5jeVN5bWJvbDogY3Vyci52YWx1ZSwgcHJlZml4OiBjdXJyLnZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcmV2KSwgeyBjdXJyZW5jeVN5bWJvbDogY3Vyci52YWx1ZSwgc3VmZml4OiBjdXJyLnZhbHVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdXJyLnR5cGUgPT09ICdncm91cCcpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldiksIHsgZ3JvdXBTZXBhcmF0b3I6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnIudHlwZSA9PT0gJ2RlY2ltYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHByZXYpLCB7IGRlY2ltYWxTZXBhcmF0b3I6IGN1cnIudmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgfSwgZGVmYXVsdENvbmZpZyk7XG59O1xuXG52YXIgaXNOdW1iZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHsgcmV0dXJuIFJlZ0V4cCgvXFxkLywgJ2dpJykudGVzdChpbnB1dCk7IH07XG5cbnZhciBwYWRUcmltVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUsIGRlY2ltYWxTZXBhcmF0b3IsIGRlY2ltYWxTY2FsZSkge1xuICAgIGlmIChkZWNpbWFsU2VwYXJhdG9yID09PSB2b2lkIDApIHsgZGVjaW1hbFNlcGFyYXRvciA9ICcuJzsgfVxuICAgIGlmIChkZWNpbWFsU2NhbGUgPT09IHVuZGVmaW5lZCB8fCB2YWx1ZSA9PT0gJycgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICghdmFsdWUubWF0Y2goL1xcZC9nKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBfYSA9IHZhbHVlLnNwbGl0KGRlY2ltYWxTZXBhcmF0b3IpLCBpbnQgPSBfYVswXSwgZGVjaW1hbHMgPSBfYVsxXTtcbiAgICBpZiAoZGVjaW1hbFNjYWxlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpbnQ7XG4gICAgfVxuICAgIHZhciBuZXdWYWx1ZSA9IGRlY2ltYWxzIHx8ICcnO1xuICAgIGlmIChuZXdWYWx1ZS5sZW5ndGggPCBkZWNpbWFsU2NhbGUpIHtcbiAgICAgICAgd2hpbGUgKG5ld1ZhbHVlLmxlbmd0aCA8IGRlY2ltYWxTY2FsZSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgKz0gJzAnO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlLnNsaWNlKDAsIGRlY2ltYWxTY2FsZSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiLmNvbmNhdChpbnQpLmNvbmNhdChkZWNpbWFsU2VwYXJhdG9yKS5jb25jYXQobmV3VmFsdWUpO1xufTtcblxuLyoqXG4gKiBCYXNlZCBvbiB0aGUgbGFzdCBrZXkgc3Ryb2tlIGFuZCB0aGUgY3Vyc29yIHBvc2l0aW9uLCB1cGRhdGUgdGhlIHZhbHVlXG4gKiBhbmQgcmVwb3NpdGlvbiB0aGUgY3Vyc29yIHRvIHRoZSByaWdodCBwbGFjZVxuICovXG52YXIgcmVwb3NpdGlvbkN1cnNvciA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBzZWxlY3Rpb25TdGFydCA9IF9hLnNlbGVjdGlvblN0YXJ0LCB2YWx1ZSA9IF9hLnZhbHVlLCBsYXN0S2V5U3Ryb2tlID0gX2EubGFzdEtleVN0cm9rZSwgc3RhdGVWYWx1ZSA9IF9hLnN0YXRlVmFsdWUsIGdyb3VwU2VwYXJhdG9yID0gX2EuZ3JvdXBTZXBhcmF0b3I7XG4gICAgdmFyIGN1cnNvclBvc2l0aW9uID0gc2VsZWN0aW9uU3RhcnQ7XG4gICAgdmFyIG1vZGlmaWVkVmFsdWUgPSB2YWx1ZTtcbiAgICBpZiAoc3RhdGVWYWx1ZSAmJiBjdXJzb3JQb3NpdGlvbikge1xuICAgICAgICB2YXIgc3BsaXRWYWx1ZSA9IHZhbHVlLnNwbGl0KCcnKTtcbiAgICAgICAgLy8gaWYgY3Vyc29yIGlzIHRvIHJpZ2h0IG9mIGdyb3VwU2VwYXJhdG9yIGFuZCBiYWNrc3BhY2UgcHJlc3NlZCwgZGVsZXRlIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIGxlZnQgb2YgdGhlIHNlcGFyYXRvciBhbmQgcmVwb3NpdGlvbiB0aGUgY3Vyc29yXG4gICAgICAgIGlmIChsYXN0S2V5U3Ryb2tlID09PSAnQmFja3NwYWNlJyAmJiBzdGF0ZVZhbHVlW2N1cnNvclBvc2l0aW9uXSA9PT0gZ3JvdXBTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIHNwbGl0VmFsdWUuc3BsaWNlKGN1cnNvclBvc2l0aW9uIC0gMSwgMSk7XG4gICAgICAgICAgICBjdXJzb3JQb3NpdGlvbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIGN1cnNvciBpcyB0byBsZWZ0IG9mIGdyb3VwU2VwYXJhdG9yIGFuZCBkZWxldGUgcHJlc3NlZCwgZGVsZXRlIHRoZSBjaGFyYWN0ZXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSBzZXBhcmF0b3IgYW5kIHJlcG9zaXRpb24gdGhlIGN1cnNvclxuICAgICAgICBpZiAobGFzdEtleVN0cm9rZSA9PT0gJ0RlbGV0ZScgJiYgc3RhdGVWYWx1ZVtjdXJzb3JQb3NpdGlvbl0gPT09IGdyb3VwU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBzcGxpdFZhbHVlLnNwbGljZShjdXJzb3JQb3NpdGlvbiwgMSk7XG4gICAgICAgICAgICBjdXJzb3JQb3NpdGlvbiArPSAxO1xuICAgICAgICB9XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBzcGxpdFZhbHVlLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4geyBtb2RpZmllZFZhbHVlOiBtb2RpZmllZFZhbHVlLCBjdXJzb3JQb3NpdGlvbjogY3Vyc29yUG9zaXRpb24gfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbW9kaWZpZWRWYWx1ZTogbW9kaWZpZWRWYWx1ZSwgY3Vyc29yUG9zaXRpb246IHNlbGVjdGlvblN0YXJ0IH07XG59O1xuXG52YXIgQ3VycmVuY3lJbnB1dCA9IGZvcndhcmRSZWYoZnVuY3Rpb24gKF9hLCByZWYpIHtcbiAgICB2YXIgX2IgPSBfYS5hbGxvd0RlY2ltYWxzLCBhbGxvd0RlY2ltYWxzID0gX2IgPT09IHZvaWQgMCA/IHRydWUgOiBfYiwgX2MgPSBfYS5hbGxvd05lZ2F0aXZlVmFsdWUsIGFsbG93TmVnYXRpdmVWYWx1ZSA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIGlkID0gX2EuaWQsIG5hbWUgPSBfYS5uYW1lLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGN1c3RvbUlucHV0ID0gX2EuY3VzdG9tSW5wdXQsIGRlY2ltYWxzTGltaXQgPSBfYS5kZWNpbWFsc0xpbWl0LCBkZWZhdWx0VmFsdWUgPSBfYS5kZWZhdWx0VmFsdWUsIF9kID0gX2EuZGlzYWJsZWQsIGRpc2FibGVkID0gX2QgPT09IHZvaWQgMCA/IGZhbHNlIDogX2QsIHVzZXJNYXhMZW5ndGggPSBfYS5tYXhMZW5ndGgsIHVzZXJWYWx1ZSA9IF9hLnZhbHVlLCBvblZhbHVlQ2hhbmdlID0gX2Eub25WYWx1ZUNoYW5nZSwgZml4ZWREZWNpbWFsTGVuZ3RoID0gX2EuZml4ZWREZWNpbWFsTGVuZ3RoLCBwbGFjZWhvbGRlciA9IF9hLnBsYWNlaG9sZGVyLCBkZWNpbWFsU2NhbGUgPSBfYS5kZWNpbWFsU2NhbGUsIHByZWZpeCA9IF9hLnByZWZpeCwgc3VmZml4ID0gX2Euc3VmZml4LCBpbnRsQ29uZmlnID0gX2EuaW50bENvbmZpZywgc3RlcCA9IF9hLnN0ZXAsIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4LCBfZSA9IF9hLmRpc2FibGVHcm91cFNlcGFyYXRvcnMsIGRpc2FibGVHcm91cFNlcGFyYXRvcnMgPSBfZSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZSwgX2YgPSBfYS5kaXNhYmxlQWJicmV2aWF0aW9ucywgZGlzYWJsZUFiYnJldmlhdGlvbnMgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZiwgX2RlY2ltYWxTZXBhcmF0b3IgPSBfYS5kZWNpbWFsU2VwYXJhdG9yLCBfZ3JvdXBTZXBhcmF0b3IgPSBfYS5ncm91cFNlcGFyYXRvciwgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgb25Gb2N1cyA9IF9hLm9uRm9jdXMsIG9uQmx1ciA9IF9hLm9uQmx1ciwgb25LZXlEb3duID0gX2Eub25LZXlEb3duLCBvbktleVVwID0gX2Eub25LZXlVcCwgdHJhbnNmb3JtUmF3VmFsdWUgPSBfYS50cmFuc2Zvcm1SYXdWYWx1ZSwgX2cgPSBfYS5mb3JtYXRWYWx1ZU9uQmx1ciwgZm9ybWF0VmFsdWVPbkJsdXIgPSBfZyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9nLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiYWxsb3dEZWNpbWFsc1wiLCBcImFsbG93TmVnYXRpdmVWYWx1ZVwiLCBcImlkXCIsIFwibmFtZVwiLCBcImNsYXNzTmFtZVwiLCBcImN1c3RvbUlucHV0XCIsIFwiZGVjaW1hbHNMaW1pdFwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImRpc2FibGVkXCIsIFwibWF4TGVuZ3RoXCIsIFwidmFsdWVcIiwgXCJvblZhbHVlQ2hhbmdlXCIsIFwiZml4ZWREZWNpbWFsTGVuZ3RoXCIsIFwicGxhY2Vob2xkZXJcIiwgXCJkZWNpbWFsU2NhbGVcIiwgXCJwcmVmaXhcIiwgXCJzdWZmaXhcIiwgXCJpbnRsQ29uZmlnXCIsIFwic3RlcFwiLCBcIm1pblwiLCBcIm1heFwiLCBcImRpc2FibGVHcm91cFNlcGFyYXRvcnNcIiwgXCJkaXNhYmxlQWJicmV2aWF0aW9uc1wiLCBcImRlY2ltYWxTZXBhcmF0b3JcIiwgXCJncm91cFNlcGFyYXRvclwiLCBcIm9uQ2hhbmdlXCIsIFwib25Gb2N1c1wiLCBcIm9uQmx1clwiLCBcIm9uS2V5RG93blwiLCBcIm9uS2V5VXBcIiwgXCJ0cmFuc2Zvcm1SYXdWYWx1ZVwiLCBcImZvcm1hdFZhbHVlT25CbHVyXCJdKTtcbiAgICBpZiAoX2RlY2ltYWxTZXBhcmF0b3IgJiYgaXNOdW1iZXIoX2RlY2ltYWxTZXBhcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZGVjaW1hbFNlcGFyYXRvciBjYW5ub3QgYmUgYSBudW1iZXInKTtcbiAgICB9XG4gICAgaWYgKF9ncm91cFNlcGFyYXRvciAmJiBpc051bWJlcihfZ3JvdXBTZXBhcmF0b3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ3JvdXBTZXBhcmF0b3IgY2Fubm90IGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuICAgIHZhciBsb2NhbGVDb25maWcgPSB1c2VNZW1vKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdldExvY2FsZUNvbmZpZyhpbnRsQ29uZmlnKTsgfSwgW2ludGxDb25maWddKTtcbiAgICB2YXIgZGVjaW1hbFNlcGFyYXRvciA9IF9kZWNpbWFsU2VwYXJhdG9yIHx8IGxvY2FsZUNvbmZpZy5kZWNpbWFsU2VwYXJhdG9yIHx8ICcnO1xuICAgIHZhciBncm91cFNlcGFyYXRvciA9IF9ncm91cFNlcGFyYXRvciB8fCBsb2NhbGVDb25maWcuZ3JvdXBTZXBhcmF0b3IgfHwgJyc7XG4gICAgaWYgKGRlY2ltYWxTZXBhcmF0b3IgJiZcbiAgICAgICAgZ3JvdXBTZXBhcmF0b3IgJiZcbiAgICAgICAgZGVjaW1hbFNlcGFyYXRvciA9PT0gZ3JvdXBTZXBhcmF0b3IgJiZcbiAgICAgICAgZGlzYWJsZUdyb3VwU2VwYXJhdG9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWNpbWFsU2VwYXJhdG9yIGNhbm5vdCBiZSB0aGUgc2FtZSBhcyBncm91cFNlcGFyYXRvcicpO1xuICAgIH1cbiAgICB2YXIgZm9ybWF0VmFsdWVPcHRpb25zID0ge1xuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiBkZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgICBncm91cFNlcGFyYXRvcjogZ3JvdXBTZXBhcmF0b3IsXG4gICAgICAgIGRpc2FibGVHcm91cFNlcGFyYXRvcnM6IGRpc2FibGVHcm91cFNlcGFyYXRvcnMsXG4gICAgICAgIGludGxDb25maWc6IGludGxDb25maWcsXG4gICAgICAgIHByZWZpeDogcHJlZml4IHx8IGxvY2FsZUNvbmZpZy5wcmVmaXgsXG4gICAgICAgIHN1ZmZpeDogc3VmZml4LFxuICAgIH07XG4gICAgdmFyIGNsZWFuVmFsdWVPcHRpb25zID0ge1xuICAgICAgICBkZWNpbWFsU2VwYXJhdG9yOiBkZWNpbWFsU2VwYXJhdG9yLFxuICAgICAgICBncm91cFNlcGFyYXRvcjogZ3JvdXBTZXBhcmF0b3IsXG4gICAgICAgIGFsbG93RGVjaW1hbHM6IGFsbG93RGVjaW1hbHMsXG4gICAgICAgIGRlY2ltYWxzTGltaXQ6IGRlY2ltYWxzTGltaXQgfHwgZml4ZWREZWNpbWFsTGVuZ3RoIHx8IDIsXG4gICAgICAgIGFsbG93TmVnYXRpdmVWYWx1ZTogYWxsb3dOZWdhdGl2ZVZhbHVlLFxuICAgICAgICBkaXNhYmxlQWJicmV2aWF0aW9uczogZGlzYWJsZUFiYnJldmlhdGlvbnMsXG4gICAgICAgIHByZWZpeDogcHJlZml4IHx8IGxvY2FsZUNvbmZpZy5wcmVmaXgsXG4gICAgICAgIHRyYW5zZm9ybVJhd1ZhbHVlOiB0cmFuc2Zvcm1SYXdWYWx1ZSxcbiAgICB9O1xuICAgIHZhciBfaCA9IHVzZVN0YXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZSAhPSBudWxsXG4gICAgICAgICAgICA/IGZvcm1hdFZhbHVlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpLCB7IGRlY2ltYWxTY2FsZTogZGVjaW1hbFNjYWxlLCB2YWx1ZTogU3RyaW5nKGRlZmF1bHRWYWx1ZSkgfSkpXG4gICAgICAgICAgICA6IHVzZXJWYWx1ZSAhPSBudWxsXG4gICAgICAgICAgICAgICAgPyBmb3JtYXRWYWx1ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZm9ybWF0VmFsdWVPcHRpb25zKSwgeyBkZWNpbWFsU2NhbGU6IGRlY2ltYWxTY2FsZSwgdmFsdWU6IFN0cmluZyh1c2VyVmFsdWUpIH0pKVxuICAgICAgICAgICAgICAgIDogJyc7XG4gICAgfSksIHN0YXRlVmFsdWUgPSBfaFswXSwgc2V0U3RhdGVWYWx1ZSA9IF9oWzFdO1xuICAgIHZhciBfaiA9IHVzZVN0YXRlKGZhbHNlKSwgZGlydHkgPSBfalswXSwgc2V0RGlydHkgPSBfalsxXTtcbiAgICB2YXIgX2sgPSB1c2VTdGF0ZSgwKSwgY3Vyc29yID0gX2tbMF0sIHNldEN1cnNvciA9IF9rWzFdO1xuICAgIHZhciBfbCA9IHVzZVN0YXRlKDApLCBjaGFuZ2VDb3VudCA9IF9sWzBdLCBzZXRDaGFuZ2VDb3VudCA9IF9sWzFdO1xuICAgIHZhciBfbSA9IHVzZVN0YXRlKG51bGwpLCBsYXN0S2V5U3Ryb2tlID0gX21bMF0sIHNldExhc3RLZXlTdHJva2UgPSBfbVsxXTtcbiAgICB2YXIgaW5wdXRSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGlucHV0UmVmLmN1cnJlbnQ7IH0pO1xuICAgIC8qKlxuICAgICAqIFByb2Nlc3MgY2hhbmdlIGluIHZhbHVlXG4gICAgICovXG4gICAgdmFyIHByb2Nlc3NDaGFuZ2UgPSBmdW5jdGlvbiAodmFsdWUsIHNlbGVjdGlvblN0YXJ0KSB7XG4gICAgICAgIHNldERpcnR5KHRydWUpO1xuICAgICAgICB2YXIgX2EgPSByZXBvc2l0aW9uQ3Vyc29yKHtcbiAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0OiBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGxhc3RLZXlTdHJva2U6IGxhc3RLZXlTdHJva2UsXG4gICAgICAgICAgICBzdGF0ZVZhbHVlOiBzdGF0ZVZhbHVlLFxuICAgICAgICAgICAgZ3JvdXBTZXBhcmF0b3I6IGdyb3VwU2VwYXJhdG9yLFxuICAgICAgICB9KSwgbW9kaWZpZWRWYWx1ZSA9IF9hLm1vZGlmaWVkVmFsdWUsIGN1cnNvclBvc2l0aW9uID0gX2EuY3Vyc29yUG9zaXRpb247XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IGNsZWFuVmFsdWUoX19hc3NpZ24oeyB2YWx1ZTogbW9kaWZpZWRWYWx1ZSB9LCBjbGVhblZhbHVlT3B0aW9ucykpO1xuICAgICAgICBpZiAodXNlck1heExlbmd0aCAmJiBzdHJpbmdWYWx1ZS5yZXBsYWNlKC8tL2csICcnKS5sZW5ndGggPiB1c2VyTWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyB8fCBzdHJpbmdWYWx1ZSA9PT0gJy0nIHx8IHN0cmluZ1ZhbHVlID09PSBkZWNpbWFsU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlICYmIG9uVmFsdWVDaGFuZ2UodW5kZWZpbmVkLCBuYW1lLCB7IGZsb2F0OiBudWxsLCBmb3JtYXR0ZWQ6ICcnLCB2YWx1ZTogJycgfSk7XG4gICAgICAgICAgICBzZXRTdGF0ZVZhbHVlKHN0cmluZ1ZhbHVlKTtcbiAgICAgICAgICAgIC8vIEFsd2F5cyBzZXRzIGN1cnNvciBhZnRlciAnLScgb3IgZGVjaW1hbFNlcGFyYXRvciBpbnB1dFxuICAgICAgICAgICAgc2V0Q3Vyc29yKDEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZVdpdGhvdXRTZXBhcmF0b3IgPSBkZWNpbWFsU2VwYXJhdG9yXG4gICAgICAgICAgICA/IHN0cmluZ1ZhbHVlLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJy4nKVxuICAgICAgICAgICAgOiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgdmFyIG51bWJlclZhbHVlID0gcGFyc2VGbG9hdChzdHJpbmdWYWx1ZVdpdGhvdXRTZXBhcmF0b3IpO1xuICAgICAgICB2YXIgZm9ybWF0dGVkVmFsdWUgPSBmb3JtYXRWYWx1ZShfX2Fzc2lnbih7IHZhbHVlOiBzdHJpbmdWYWx1ZSB9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpKTtcbiAgICAgICAgaWYgKGN1cnNvclBvc2l0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgY3Vyc29yIGp1bXBpbmdcbiAgICAgICAgICAgIHZhciBuZXdDdXJzb3IgPSBjdXJzb3JQb3NpdGlvbiArIChmb3JtYXR0ZWRWYWx1ZS5sZW5ndGggLSB2YWx1ZS5sZW5ndGgpO1xuICAgICAgICAgICAgbmV3Q3Vyc29yID0gbmV3Q3Vyc29yIDw9IDAgPyAocHJlZml4ID8gcHJlZml4Lmxlbmd0aCA6IDApIDogbmV3Q3Vyc29yO1xuICAgICAgICAgICAgc2V0Q3Vyc29yKG5ld0N1cnNvcik7XG4gICAgICAgICAgICBzZXRDaGFuZ2VDb3VudChjaGFuZ2VDb3VudCArIDEpO1xuICAgICAgICB9XG4gICAgICAgIHNldFN0YXRlVmFsdWUoZm9ybWF0dGVkVmFsdWUpO1xuICAgICAgICBpZiAob25WYWx1ZUNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlcyA9IHtcbiAgICAgICAgICAgICAgICBmbG9hdDogbnVtYmVyVmFsdWUsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkOiBmb3JtYXR0ZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogc3RyaW5nVmFsdWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgb25WYWx1ZUNoYW5nZShzdHJpbmdWYWx1ZSwgbmFtZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGNoYW5nZSBldmVudFxuICAgICAqL1xuICAgIHZhciBoYW5kbGVPbkNoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2EgPSBldmVudC50YXJnZXQsIHZhbHVlID0gX2EudmFsdWUsIHNlbGVjdGlvblN0YXJ0ID0gX2Euc2VsZWN0aW9uU3RhcnQ7XG4gICAgICAgIHByb2Nlc3NDaGFuZ2UodmFsdWUsIHNlbGVjdGlvblN0YXJ0KTtcbiAgICAgICAgb25DaGFuZ2UgJiYgb25DaGFuZ2UoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGZvY3VzIGV2ZW50XG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uRm9jdXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgb25Gb2N1cyAmJiBvbkZvY3VzKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsdWUgPyBzdGF0ZVZhbHVlLmxlbmd0aCA6IDA7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYmx1ciBldmVudFxuICAgICAqXG4gICAgICogRm9ybWF0IHZhbHVlIGJ5IHBhZGRpbmcvdHJpbW1pbmcgZGVjaW1hbHMgaWYgcmVxdWlyZWQgYnlcbiAgICAgKi9cbiAgICB2YXIgaGFuZGxlT25CbHVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGV2ZW50LnRhcmdldC52YWx1ZTtcbiAgICAgICAgdmFyIHZhbHVlT25seSA9IGNsZWFuVmFsdWUoX19hc3NpZ24oeyB2YWx1ZTogdmFsdWUgfSwgY2xlYW5WYWx1ZU9wdGlvbnMpKTtcbiAgICAgICAgaWYgKHZhbHVlT25seSA9PT0gJy0nIHx8IHZhbHVlT25seSA9PT0gZGVjaW1hbFNlcGFyYXRvciB8fCAhdmFsdWVPbmx5KSB7XG4gICAgICAgICAgICBzZXRTdGF0ZVZhbHVlKCcnKTtcbiAgICAgICAgICAgIG9uQmx1ciAmJiBvbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXhlZERlY2ltYWxzID0gZml4ZWREZWNpbWFsVmFsdWUodmFsdWVPbmx5LCBkZWNpbWFsU2VwYXJhdG9yLCBmaXhlZERlY2ltYWxMZW5ndGgpO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBwYWRUcmltVmFsdWUoZml4ZWREZWNpbWFscywgZGVjaW1hbFNlcGFyYXRvciwgZGVjaW1hbFNjYWxlICE9PSB1bmRlZmluZWQgPyBkZWNpbWFsU2NhbGUgOiBmaXhlZERlY2ltYWxMZW5ndGgpO1xuICAgICAgICB2YXIgbnVtYmVyVmFsdWUgPSBwYXJzZUZsb2F0KG5ld1ZhbHVlLnJlcGxhY2UoZGVjaW1hbFNlcGFyYXRvciwgJy4nKSk7XG4gICAgICAgIHZhciBmb3JtYXR0ZWRWYWx1ZSA9IGZvcm1hdFZhbHVlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpLCB7IHZhbHVlOiBuZXdWYWx1ZSB9KSk7XG4gICAgICAgIGlmIChvblZhbHVlQ2hhbmdlICYmIGZvcm1hdFZhbHVlT25CbHVyKSB7XG4gICAgICAgICAgICBvblZhbHVlQ2hhbmdlKG5ld1ZhbHVlLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgZmxvYXQ6IG51bWJlclZhbHVlLFxuICAgICAgICAgICAgICAgIGZvcm1hdHRlZDogZm9ybWF0dGVkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0U3RhdGVWYWx1ZShmb3JtYXR0ZWRWYWx1ZSk7XG4gICAgICAgIG9uQmx1ciAmJiBvbkJsdXIoZXZlbnQpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGtleSBkb3duIGV2ZW50XG4gICAgICpcbiAgICAgKiBJbmNyZWFzZSBvciBkZWNyZWFzZSB2YWx1ZSBieSBzdGVwXG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIga2V5ID0gZXZlbnQua2V5O1xuICAgICAgICBzZXRMYXN0S2V5U3Ryb2tlKGtleSk7XG4gICAgICAgIGlmIChzdGVwICYmIChrZXkgPT09ICdBcnJvd1VwJyB8fCBrZXkgPT09ICdBcnJvd0Rvd24nKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHNldEN1cnNvcihzdGF0ZVZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gcGFyc2VGbG9hdCh1c2VyVmFsdWUgIT0gbnVsbFxuICAgICAgICAgICAgICAgID8gU3RyaW5nKHVzZXJWYWx1ZSkucmVwbGFjZShkZWNpbWFsU2VwYXJhdG9yLCAnLicpXG4gICAgICAgICAgICAgICAgOiBjbGVhblZhbHVlKF9fYXNzaWduKHsgdmFsdWU6IHN0YXRlVmFsdWUgfSwgY2xlYW5WYWx1ZU9wdGlvbnMpKSkgfHwgMDtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGtleSA9PT0gJ0Fycm93VXAnID8gY3VycmVudFZhbHVlICsgc3RlcCA6IGN1cnJlbnRWYWx1ZSAtIHN0ZXA7XG4gICAgICAgICAgICBpZiAobWluICE9PSB1bmRlZmluZWQgJiYgbmV3VmFsdWUgPCBOdW1iZXIobWluKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBuZXdWYWx1ZSA+IE51bWJlcihtYXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpeGVkTGVuZ3RoID0gU3RyaW5nKHN0ZXApLmluY2x1ZGVzKCcuJylcbiAgICAgICAgICAgICAgICA/IE51bWJlcihTdHJpbmcoc3RlcCkuc3BsaXQoJy4nKVsxXS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwcm9jZXNzQ2hhbmdlKFN0cmluZyhmaXhlZExlbmd0aCA/IG5ld1ZhbHVlLnRvRml4ZWQoZml4ZWRMZW5ndGgpIDogbmV3VmFsdWUpLnJlcGxhY2UoJy4nLCBkZWNpbWFsU2VwYXJhdG9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25LZXlEb3duICYmIG9uS2V5RG93bihldmVudCk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUga2V5IHVwIGV2ZW50XG4gICAgICpcbiAgICAgKiBNb3ZlIGN1cnNvciBpZiB0aGVyZSBpcyBhIHN1ZmZpeCB0byBwcmV2ZW50IHVzZXIgdHlwaW5nIHBhc3Qgc3VmZml4XG4gICAgICovXG4gICAgdmFyIGhhbmRsZU9uS2V5VXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGtleSA9IGV2ZW50LmtleSwgc2VsZWN0aW9uU3RhcnQgPSBldmVudC5jdXJyZW50VGFyZ2V0LnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICBpZiAoa2V5ICE9PSAnQXJyb3dVcCcgJiYga2V5ICE9PSAnQXJyb3dEb3duJyAmJiBzdGF0ZVZhbHVlICE9PSAnLScpIHtcbiAgICAgICAgICAgIHZhciBzdWZmaXhfMSA9IGdldFN1ZmZpeChzdGF0ZVZhbHVlLCB7IGdyb3VwU2VwYXJhdG9yOiBncm91cFNlcGFyYXRvciwgZGVjaW1hbFNlcGFyYXRvcjogZGVjaW1hbFNlcGFyYXRvciB9KTtcbiAgICAgICAgICAgIGlmIChzdWZmaXhfMSAmJiBzZWxlY3Rpb25TdGFydCAmJiBzZWxlY3Rpb25TdGFydCA+IHN0YXRlVmFsdWUubGVuZ3RoIC0gc3VmZml4XzEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoaW5wdXRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3Q3Vyc29yID0gc3RhdGVWYWx1ZS5sZW5ndGggLSBzdWZmaXhfMS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQuc2V0U2VsZWN0aW9uUmFuZ2UobmV3Q3Vyc29yLCBuZXdDdXJzb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBvbktleVVwICYmIG9uS2V5VXAoZXZlbnQpO1xuICAgIH07XG4gICAgLy8gVXBkYXRlIHN0YXRlIGlmIHVzZXJWYWx1ZSBjaGFuZ2VzIHRvIHVuZGVmaW5lZFxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh1c2VyVmFsdWUgPT0gbnVsbCAmJiBkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgc2V0U3RhdGVWYWx1ZSgnJyk7XG4gICAgICAgIH1cbiAgICB9LCBbZGVmYXVsdFZhbHVlLCB1c2VyVmFsdWVdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBwcmV2ZW50IGN1cnNvciBqdW1waW5nIGlmIGVkaXRpbmcgdmFsdWVcbiAgICAgICAgaWYgKGRpcnR5ICYmXG4gICAgICAgICAgICBzdGF0ZVZhbHVlICE9PSAnLScgJiZcbiAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGlucHV0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlucHV0UmVmLmN1cnJlbnQuc2V0U2VsZWN0aW9uUmFuZ2UoY3Vyc29yLCBjdXJzb3IpO1xuICAgICAgICB9XG4gICAgfSwgW3N0YXRlVmFsdWUsIGN1cnNvciwgaW5wdXRSZWYsIGRpcnR5LCBjaGFuZ2VDb3VudF0pO1xuICAgIC8qKlxuICAgICAqIElmIHVzZXIgaGFzIG9ubHkgZW50ZXJlZCBcIi1cIiBvciBkZWNpbWFsIHNlcGFyYXRvcixcbiAgICAgKiBrZWVwIHRoZSBjaGFyIHRvIGFsbG93IHRoZW0gdG8gZW50ZXIgbmV4dCB2YWx1ZVxuICAgICAqL1xuICAgIHZhciBnZXRSZW5kZXJWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHVzZXJWYWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgICBzdGF0ZVZhbHVlICE9PSAnLScgJiZcbiAgICAgICAgICAgICghZGVjaW1hbFNlcGFyYXRvciB8fCBzdGF0ZVZhbHVlICE9PSBkZWNpbWFsU2VwYXJhdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdFZhbHVlKF9fYXNzaWduKF9fYXNzaWduKHt9LCBmb3JtYXRWYWx1ZU9wdGlvbnMpLCB7IGRlY2ltYWxTY2FsZTogZGlydHkgPyB1bmRlZmluZWQgOiBkZWNpbWFsU2NhbGUsIHZhbHVlOiBTdHJpbmcodXNlclZhbHVlKSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0YXRlVmFsdWU7XG4gICAgfTtcbiAgICB2YXIgaW5wdXRQcm9wcyA9IF9fYXNzaWduKHsgdHlwZTogJ3RleHQnLCBpbnB1dE1vZGU6ICdkZWNpbWFsJywgaWQ6IGlkLCBuYW1lOiBuYW1lLCBjbGFzc05hbWU6IGNsYXNzTmFtZSwgb25DaGFuZ2U6IGhhbmRsZU9uQ2hhbmdlLCBvbkJsdXI6IGhhbmRsZU9uQmx1ciwgb25Gb2N1czogaGFuZGxlT25Gb2N1cywgb25LZXlEb3duOiBoYW5kbGVPbktleURvd24sIG9uS2V5VXA6IGhhbmRsZU9uS2V5VXAsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgZGlzYWJsZWQ6IGRpc2FibGVkLCB2YWx1ZTogZ2V0UmVuZGVyVmFsdWUoKSwgcmVmOiBpbnB1dFJlZiB9LCBwcm9wcyk7XG4gICAgaWYgKGN1c3RvbUlucHV0KSB7XG4gICAgICAgIHZhciBDdXN0b21JbnB1dCA9IGN1c3RvbUlucHV0O1xuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChDdXN0b21JbnB1dCwgX19hc3NpZ24oe30sIGlucHV0UHJvcHMpKTtcbiAgICB9XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiLCBfX2Fzc2lnbih7fSwgaW5wdXRQcm9wcykpO1xufSk7XG5DdXJyZW5jeUlucHV0LmRpc3BsYXlOYW1lID0gJ0N1cnJlbmN5SW5wdXQnO1xuXG5leHBvcnQgeyBjbGVhblZhbHVlLCBDdXJyZW5jeUlucHV0IGFzIGRlZmF1bHQsIGZvcm1hdFZhbHVlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-currency-input-field/dist/index.esm.js\n");

/***/ })

};
;